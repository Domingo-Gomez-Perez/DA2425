#lang racket

#|
**Exercise 1.9**: Each of the following two procedures defines a
method for adding two positive integers in terms of the procedures
`inc`, which increments its argument by 1, and `dec`, which decrements
its argument by 1.

```
(define (inc x) (+ x 1))
(define (dec x) (- x 1))

(define (plus a b)
  (if (= a 0) 
      b 
      (inc (plus (dec a) b))))

(define (plus a b)
  (if (= a 0) 
      b 
      (plus (dec a) (inc b))))
```

Using the substitution model, illustrate the process generated by each
procedure in evaluating `(plus 4 5)`.  Are these processes iterative or
recursive?

|#

(define (inc x) (+ x 1))
(define (dec x) (- x 1))



(define (plus a b)
  (if (= a 0) 
      b 
      (inc (plus (dec a) b))))



#|

Explicación método 1, el de arriba:

(plus 6 7)

  (if ( = 6 0) 7 (inc (plus 5 7)))

  (inc (inc (plus 4 7)))

  (inc (inc( inc (plus 3 7))))

  (inc(inc (inc( inc (plus 2 7)))))

  (inc(inc(inc (inc( inc (plus 1 7))))))

  (inc(inc(inc(inc (inc( inc (plus 0 7)))))))

  (inc(inc(inc(inc (inc( inc 7))))))

   Este método es recursivo debido a que se llama a sí mismo comparando en cada llamada si a es igual a 0 y en caso de que no lo sea
   lo que hace es llamarse a sí mismo con la diferencia de que el valor de a decrementa en 1 y e valor de b sigue siendo el mismo.
   Entonces, cuando finalmente el valor del primer argumento sea 0 y se llama a la misma función lo que se hace porque a es igual 0
   tras las llamadas recursivas es devolver
   el valor de b que será:

   (inc(inc(inc(inc (inc( inc 7)))))) = 7 + 1 + 1 + 1 + 1 + 1 + 1 = 13

   Se mostrará 13.


|#

#|

Explicación método 2:

(define (plus a b)
  (if (= a 0) 
      b 
      (plus (dec a) (inc b))))

Este método es recursivo porque realiza una llamada a sí mismo y pasa lo siguiente si (plus 6 7):

(if (= a 0) 7 (plus 5 8))
(plus 4 9)
(plus 3 10)
(plus 2 11)
(plus 1 12)
(plus 0 13)

Entonces, este método comprueba si a es igual a 0 (en este caso devuelve el valor del segundo argumento (b), y si no lo es
lo que hace es llamarse recursivamente con la distinción  del valor de los argumentos, decrementando en uno el primer argumento e
incrementando lo mismo en el segundo argumento, hasta que el valor del a sea 0 y es cuando entonces devuelve el valor de b que ha ido
aumentando y que en este caso es 13. La diferencia con el método 1 radica en que en cada llamada recursiva este método se llama a sí
mismo con sus argumentos modificados  (el primero decrementa y el segundo aumenta), lo que hace que en cada llamada el valor de b vaya
aumentando en 1 hasta que a sea 0 y es cuando se devuelve el valor de b, en cambio, en el anterior, tras llamarse recursivamente no
se incrementa el valor de b hasta que a sea 0.

|#



