#lang racket

; recursivo
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
;(* 6 (factorial (- 6 1)))
;(* 6 (* 5 (factorial (- 5 1))))
;(* 6 (* 5 (* 4 (factorial (- 4 1)))))
;(* 6 (* 5 (* 4 (* 3 (factorial (- 3 1))))))
;(* 6 (* 5 (* 4 (* 3 (* 2 (factorial (- 2 1)))))))
;(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
;(* 6 (* 5 (* 4 (* 3 2))))
;(* 6 (* 5 (* 4 6)))
;(* 6 (* 5 24))
;(* 6 120)
;720

;La complejidad temporal es 0(n) y la espacial, al tener que guardar el 6, 5, 4, 3, 2, 1 es 0(n)


; iterativo
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product 
                   counter 
                   max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))